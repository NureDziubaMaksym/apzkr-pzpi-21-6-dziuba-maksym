РЕФЕРАТ


Пояснювальна записка до курсової роботи: 27 с., 7 рис., 2 додатки, 4 джерел.
КОНТЕНТ, ЕМОЦІЇ, ІоТ, СЕРВІС, ФРОНТЕНД, БАЗА ДАНИХ, ВЕБ-РОЗРОБКА, ОБ’ЄКТНО-ОРІЄНТОВАНЕ ПРОГРАМУВАННЯ, С#.
Метою роботи є розробка програмної системи для оцінювання емоцій/зацікавленості контентом, яка дозволяє здійснювати моніторинг реакцій користувачів на різні типи контенту (лекції, кіно, тренінги) та надавати відповідні звіти.
Розробка базується на використанні сучасних технологій: Microsoft Visual Studio 2022, платформи .NET 6.0, бази даних PostgreSQL, фреймворку React для фронтенд-розробки та IoT пристроїв для збору емоційних даних. Програма реалізує механізми реєстрації нових користувачів, запису в фокус-групи, організації сесій перегляду контенту, а також збору та аналізу емоційних реакцій.
У роботі детально описані алгоритми взаємодії між компонентами системи, структурою бази даних та методи обробки інформації. Також включені UML-діаграми, що ілюструють архітектуру та функціональність системи.
Завдяки реалізованій програмній системі, адміністратори можуть створювати групи користувачів на основі певних критеріїв, таких як стать, вік та раса, проводити аналітику емоційних реакцій, та генерувати звіти для подальшого використання.

 
ЗМІСТ

ЗМІСТ	6
ВСТУП	7
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.2	Методи зворотного зв'язку	8
1.3	Вимірювання на основі датчиків	9
1.4	Потреби аудиторії та системні вимоги	10
2	ПРОЕКТУВАННЯ АРХІТЕКТУРИ СИСТЕМИ	11
2.1	Загальна архітектура системи	11
2.2	Дизайн бази даних	12
2.3	Взаємодія з базою даних	13
3	ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ	14
3.1	Загальний опис архітектури	14
3.2	Шари архітектури	15
3.3	REST архітектура	16
4	ОПИС АРХІТЕКТУРИ IoT ПРИСТРОЮ	18
4.1	Побудова wifi модулю та архітектура	18
4.2	Взаємодія з іншими частинами	19
5	ОПИС АРХІТЕКТУРИ ФРОНТЕНД ЧАСТИНИ	22
5.1	Загальна структура системи	22
ВИСНОВКИ	25
ПЕРЕЛІК ПОСЛИАННЬ	26
ДОДАТОК А	27
ДОДАТОК Б	30




 
ВСТУП


Оскільки цифрові платформи продовжують домінувати в споживанні інформації, розваг та освіти, розуміння того, як користувачі емоційно реагують на контент, стає все більш важливим. Незалежно від того, чи це тренінг, лекція чи фільм, здатність оцінити рівень емоційності та зацікавленості аудиторії може надати розуміння творцям контенту як можна його покращити.
В основі цього проекту лежить розробка програмної системи, яка здатна не лише керувати реєстрацією користувачів і призначенням груп на основі різних критеріїв, таких як стать, раса та вік, а й інтегрувати технологію Інтернету речей (IoT) у фіксувати емоційні дані користувачів у реальному часі. Потім ці дані передаються в центральну базу даних, де їх можна проаналізувати для визначення ефективності контенту.
У сучасному світі вміння ефективно залучати аудиторію є ключовим чинником успіху. Незалежно від того, чи є контент навчальним або розважальним, розуміння емоційних реакцій, які він викликає у аудиторії, може допомогти вдосконалити та адаптувати контент, щоб краще відповідати потребам і очікуванням користувачів. Це особливо важливо в таких сферах, як онлайн-освіта, де підтримка залученості студентів має вирішальне значення для процесу навчання, або в маркетингу, де емоційна залученість може суттєво вплинути на поведінку споживачів.
Система побудована на базі операційної системи Windows 11, використовує PostgresSQL Server як систему керування базою даних і розроблена в середовищі Microsoft Visual Studio 2022. Інтерфейс системи розроблено з використанням фреймворку React, який відомий своєю гнучкістю та ефективністю у створенні інтерфейсів користувача.
 
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Сучасні методи і технології


Останніми роками сфера оцінки емоцій і залучення привернула значну увагу, особливо в контексті споживання контенту, такого як тренінги, лекції, фільми та інші форми медіа. Розуміння того, як користувачі емоційно та когнітивно взаємодіють із контентом, може надати цінну інформацію для творців контенту, педагогів і маркетологів.
Сучасні методи оцінки емоцій і залучення користувачів зазвичай діляться на дві категорії: методи прямого зворотного зв’язку та вимірювання на основі датчиків.


1.2	Методи зворотного зв'язку


Опитування та анкети: користувачів просять надати відгук про свій емоційний стан і рівень залученості після перегляду контенту. Незважаючи на те, що цей метод простий, він суб’єктивний і на нього може вплинути бажання користувача надати чесні відповіді. Фокус-групи: це невеликі цільові обговорення, де учасників запитують про їхню реакцію на вміст. Цей метод дозволяє отримати глибше розуміння, але займає багато часу та не піддається масштабуванню.


1.3	Вимірювання на основі датчиків


Технологія розпізнавання обличчя: ця технологія використовує камери для аналізу виразу обличчя та визначення емоційного стану. Він надає ненав’язливу інформацію в режимі реального часу, але потребує складних алгоритмів і викликає проблеми з конфіденційністю.
Фізіологічні датчики: такі пристрої, як монітори серцевого ритму та електрошкірні датчики активності, вимірюють фізіологічні реакції на вміст. Ці методи можуть точно відображати залучення та емоційне збудження, але вимагають від користувачів носіння пристроїв, що не завжди може бути практичним.






 
1.4	Потреби аудиторії та системні вимоги


Основними користувачами системи оцінки емоцій і залучення є творці контенту, педагоги та дослідники ринку, яким потрібні надійні дані в реальному часі про те, як їхня аудиторія взаємодіє з контентом.
Точність і надійність: система повинна надавати точні та надійні дані про емоції користувачів і рівень залучення, щоб бути цінною для користувачів.
Ненав'язливий моніторинг: система повинна збирати дані таким чином, щоб не заважати взаємодії з користувачем. Щоб забезпечити природну поведінку користувача, перевагу надають ненав’язливим методам.
Масштабованість: рішення має бути здатним обробляти великі обсяги даних і бути застосовним до різних типів вмісту, від відео та лекцій до живих подій.
 
2	ПРОЕКТУВАННЯ АРХІТЕКТУРИ СИСТЕМИ
2.1	Загальна архітектура системи


Архітектура системи розроблена з чітким розподілом проблем, що забезпечує модульність, масштабованість і зручність обслуговування. На високому рівні система розділена на кілька ключових компонентів, кожен з яких відповідає за певний набір функцій. Ці компоненти взаємодіють один з одним через чітко визначені інтерфейси, гарантуючи, що зміни в одній частині системи не впливають негативно на інші.

Рівень інтерфейсу користувача: цей рівень включає всі компоненти, які безпосередньо взаємодіють з користувачем. Він забезпечує інтуїтивно зрозумілий інтерфейс для взаємодії користувачів із системою, незалежно від того, чи є вони творцями контенту, викладачами чи аналітиками. Інтерфейс користувача побудовано з використанням сучасних веб-технологій, що забезпечує швидке реагування та зручність роботи. Використання такого фреймворку, як React, гарантує, що користувальницький інтерфейс є не лише динамічним, але й простим у підтримці та розширенні.
Основний рівень програми: це серце системи, де знаходиться бізнес-логіка. Він включає в себе модулі, відповідальні за обробку введених даних користувачами, керування сеансами, обробку фокус-груп і виконання аналізу емоцій і залучення. Основний рівень розроблено таким чином, щоб він був незалежним від інтерфейсу користувача, що означає, що його можна легко адаптувати або розширити, не впливаючи на інтерфейс. Цей рівень забезпечує послідовне застосування всіх бізнес-правил у всій системі.
Рівень доступу до даних: цей рівень відповідає за всі взаємодії з базою даних. Він керує зберіганням і отриманням даних, забезпечуючи надійне збереження стану системи. Рівень доступу до даних використовує Entity Framework Core як інструмент ORM (Object-Relational Mapping) для ефективного керування операціями бази даних. Використання PostgreSQL як бази даних гарантує, що система може обробляти великі обсяги даних, зберігаючи високу продуктивність.


2.2	Дизайн бази даних


Таблиця сесій: у цій таблиці записуються всі дані, пов’язані із сеансом, включаючи час початку та завершення, пов’язаний вміст і пов’язані фокус-групи. 
Таблиця фокус-груп: керує інформацією про фокус-групи, які використовуються для сегментації користувачів на основі певних критеріїв, таких як вік, стать або інтереси.
Таблиця результатів: зберігає результати аналізу емоцій і залучення, пов’язуючи кожен запис із певним сеансом і користувачем. 
Таблиця користувачів: зберігає пов’язану з користувачем інформацію, включаючи облікові дані для входу, ролі та особисті дані. Кожному користувачеві присвоюється унікальний ідентифікатор, який використовується для керування його взаємодією з системою.
Таблиця контенту зберігає дані про контент, який аналізується під час роботи програми.
Таблиця реакцій зберігає коментарі користувачів, оцінки які користувачі залишають після перегляду, а також розрахований конфіцент зацікавленості. Дані з цієї таблиці відповідають за функціонал зворотного зв’язку.
На рисунку 1.1 зображено схему бази даних проекту.
 
 
Рисунок 1.1 – Схема бази даних


2.3	Взаємодія з базою даних


Для взаємодії з базою даних використовується Entity Framework Core, який є ORM (Object-Relational Mapping) для .NET. Entity Framework Core дозволяє працювати з даними у базі даних як з об'єктами C#, що спрощує розробку та обслуговування програми. 
Entity Framework Core: Забезпечує роботу з PostgreSQL базою даних. Усі сутності програми (користувачі, сесії, фокус-групи тощо) відображаються на відповідні таблиці у базі даних.

 
3	ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ
3.1	Загальний опис архітектури


Архітектура серверного додатка побудована на базі сучасних принципів та технологій для забезпечення надійності, масштабованості та безпеки системи. Основні компоненти архітектури включають контролери, сервіси, репозиторії, автентифікацію та авторизацію та роботу з базою даних через Entity Framework Core.
Контролери відіграють роль посередників між клієнтом та бізнес-логікою програми. Кожен контролер відповідає за обробку HTTP-запитів, що отримуються від клієнта, та передачу даних у відповідні сервіси чи репозиторії. Контролери також обробляють відповіді від сервісів та повертають їх клієнту у вигляді HTTP-відповідей.
Сервіси інкапсулюють бізнес-логіку програми та забезпечують виконання операцій, необхідних для обробки даних. Сервіси реалізують основні функціональні можливості програми, такі як створення та верифікація паролів, генерація унікальних ідентифікаторів та інші.
Репозиторії відповідальні за взаємодію з базою даних. Вони надають методи виконання CRUD-операцій (створення, читання, оновлення, видалення) з даними. Репозиторії абстрагують рівень доступу до даних від бізнес-логіки програми, що дозволяє легко модифікувати або замінювати технології роботи з базою даних без зміни основної логіки програми.
Система аутентифікації та авторизації побудована на основі JWT (JSON Web Token). Для кожної автентифікованої сесії користувача генерується токен, який зберігає інформацію про користувача, включаючи його роль системі. Авторизація керується за допомогою атрибутів Authorize, які забезпечують доступ до певних ресурсів та дій лише авторизованим користувачам з відповідною роллю.


3.2	Шари архітектури


Рішення було розбито на шари відповідно до багаторівневої архітектури. Було створено три проекти: Backend (user interface), Backend.Core (business logic) та Backend.Infrastructure (data access). 
Проект Backend відповідає за конфігурацію Web Api, за контроллери та роути.
Проект Backend.Core відповідає за бізнес логіку, тобто зберігає в собі інтерфейси, моделі dto та сервіси для взаємодії з данними та їх обробки. Проект Backend.Infrastructure відповідає за створення бази даних та забезпечення доступу до даних. Цей рівень додатку зберігає в собі міграції бази даних, моделі для Entity Framework, які забезпечують коректне використання ORM-технології, їх конфігурації, та зберігає конфігурацію контекста бази даних, який забезпечує підключення до даних.
На діаграмі компонентів показано архітектура серверного додатка, що відбиває основні функціональні блоки системи та його взаємодія друг з одним. Діаграма ділиться на три ключові шари, кожен з яких виконує свою роль у загальній структурі програми.
 
 
Рисунок 2.1 – Діаграма компонентів


3.3	REST архітектура


При написанні запитів було дотримано принципів REST. Повна таблиця реалізованих REST запитів наведено у додатку А. REST – підхід до архітектури мережевих протоколів, які надають доступ до інформаційних ресурсів. В основі REST закладено принципи функціонування Всесвітньої павутини і, зокрема, можливості HTTP. Усі ресурси, які характеризують колекцію, тобто перелік даних мають назву в множині, а ті які характеризують одиночний ресурс – в однині. Для роутів для запитів використовується підмети та не використовуються присудки, такі як get, post тощо. У get-запитах дані передаються зі строки запита, а post, delete, update – інформація передається в тілі запиту
На діаграмі прецедентів, на рисунку 2.2 зображено основні взаємодії користувачів із системою, які класифіковані за двома типами користувачів: Адміністратор та Користувач. Діаграма показує, які операції доступні для кожного типу користувачів і як вони взаємодіють із різними компонентами системи.

 
Рисунок 2.2 – діаграма прецедентів API інтерфейсів користувачів
 
4	ОПИС АРХІТЕКТУРИ IoT ПРИСТРОЮ
4.1	Побудова wifi модулю та архітектура


У ході роботи, було запрограмовано WiFi модуль ESP32 за допомогою симулятора Wokwi. Було під'єднано датчик температури та вологості DHT22. А також розроблено модуль, який емулює заміри серцебиття людини, а також пітливості та температури. Модуль ESP за допомогою WIFI клієнта з програмного коду відсилає повідомлення на сервер за допомогою MQTT протоколу. У якості брокера використовувався HiveMQ cloud. 
Wokwi — онлайн-симулятор електроніки. Він може використовуватись для симуляції Arduino, ESP32 та багатьох інших популярних плат, деталей і датчиків. 
MQTT (Message Queue Telemetry Transport) — спрощений мережевий протокол, що працює на TCP/IP. Використовується для обміну повідомленнями між пристроями за принципом видавець-підписник.
Архітектура системи є розподіленим рішенням, в якому IoT-пристрій (ESP32) взаємодіє з серверною частиною через MQTT-протокол. Основна мета пристрою – збір даних із підключених сенсорів, аналіз цих даних та їх відправлення на сервер для подальшої обробки та зберігання. Серверна частина, реалізована на ASP.NET Web API, забезпечує зберігання даних у базі даних та надає інтерфейс взаємодії з користувачами.
На рисунку 3.1 зображено зовнішній вигляд онлайн симулятору. Ми можемо побачити модуль ESP32 та під’єднані датчики: DHT-22, bpm-sensor. Слід зазначити, що датчик серцебиття було розроблено власноруч. Код роботи програми наведено в Додатку Б.
 
 
Рисунок 3.1 – Wokwi емулятор


4.2	Взаємодія з іншими частинами


Нижче наведена діаграма взаємодії ілюструє процес обміну даними між різними компонентами системи IoT-пристрою, який аналізує емоційний стан користувача. Архітектура системи включає кілька ключових компонентів: мікроконтролер ESP32, MQTT-брокер, серверний API на ASP.NET та базу даних. Діаграма демонструє послідовність взаємодій, що відбуваються різних етапах роботи системи, від отримання конфігураційних даних до відправлення і обробки емоційних даних.

 
Рисунок 3.2 – Загальна діаграма взаємодії.

Діаграма діяльності, наведена нижче, відображає послідовність операцій та рішень, що виконуються в рамках роботи системи аналізу емоційного стану користувача. Діаграма охоплює ключові етапи процесу, від збирання та відправлення даних до перевірки стану та аналізу часових рамок.
 
 
Рисунок 3.3 – Діаграма діяльності.


 
5	ОПИС АРХІТЕКТУРИ ФРОНТЕНД ЧАСТИНИ
5.1	Загальна структура системи


Система побудована на основі багатосторінкового веб-програми з використанням бібліотеки React для фронтенда.
Фронтенд відповідає за відображення інтерфейсу користувача і взаємодію з користувачем. Він включає наступні основні компоненти:
1) Router: Використовується react-router-dom для маршрутизації. Це дозволяє створювати SPA, де перехід між сторінками відбувається без перезавантаження.
2) Компоненти: Кожна сторінка представлена окремим компонентом. Наприклад, Sessions, Users, Groups, Contents тощо. Ці компоненти відповідають за рендеринг відповідних даних та взаємодію з API.
3) Локалізація: Для підтримки кількох мов використовується react-i18next. Це дозволяє легко перекладати інтерфейс різними мовами.
4) Сайдбар:  забезпечує навігацію по різних розділах програми. Він також включає перемикач мови зміни локалізації інтерфейсу.
5) Стан компонентів: Внутрішній стан кожного компонента керується за допомогою хуків, використовуючиState і useEffect. Це дозволяє компонентам динамічно оновлюватись залежно від даних, отриманих із сервера.

 
Рисунок 4.1 – Структура проекту

Компоненти фронтенду надсилають HTTP-запити до API бекенду для отримання даних або виконання дій (наприклад, додавання нової сесії). Відповіді API обробляються на фронтенді та відображаються користувачеві. Якщо запит успішно, дані оновлюються на сторінці. Якщо виникають помилки, вони відображаються користувачеві. Розроблена система є гнучким та масштабованим рішенням для управління сесіями, користувачами, групами та контентом. Завдяки використанню сучасних технологій, таких як React та REST API, система легко розширюється та підтримує багаторазове використання компонентів та функціоналу. Локалізація дозволяє використовувати систему користувачам з різними мовними уподобаннями, що робить її зручною та універсальною.
 
ВИСНОВКИ


Цей проект ефективно об’єднав пристрої IoT, надійну серверну інфраструктуру та адаптивний зовнішній інтерфейс для створення системи, яка оцінює емоційні реакції на різні форми контенту, такі як тренінги, лекції та розваги.
Вибір PostgreSQL для бази даних і використання Entity Framework Core для ORM забезпечили ефективність і надійність обробки даних. База даних добре структурована, підтримує складні вимоги, такі як керування сеансами користувачів і фокус-групами. Система також наголошує на безпеці, використовуючи такі заходи, як хешування паролів і контроль доступу на основі ролей, що захищає конфіденційні дані.
На інтерфейсі програма на основі React пропонує зручний інтерфейс, що полегшує взаємодію з системою як для учасників, так і для адміністраторів. Користувачі можуть легко реєструватися на сеанси, приєднуватися до фокус-груп і переглядати результати, тоді як адміністратори мають доступ до більш повних функцій керування. Це розрізнення на основі ролей має вирішальне значення для підтримки безпеки та контролю доступу.

 
ПЕРЕЛІК ПОСЛИАННЬ


1. ДСТУ 3008:2015 Інформація та документація. Звіти у сфері науки і техніки. Структура та правила оформлювання. К.: ДП «УкрНДНЦ», 2016. 26 с. 
2. ДСТУ 8302:2015. Інформація та документація. Бібліографічне посилання. Загальні положення та правила складання. К.: ДП «УкрНДНЦ», 2016. – 16 с
3. Microsoft. C# Programming Guide. [Електронний ресурс]. – Режим доступу: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/ 
4. Microsoft. .NET API Browser. [Електронний ресурс]. – Режим доступу: https://learn.microsoft.com/en-us/dotnet/api/
 
ДОДАТОК А


Таблиця 1 – REST-специфікація
Назва	Метод	Шлях	Тіло
UsersGet	Get	/users/get	
UsersGetById	Get	/users /get/{id}	
UserDelete	Delete	/users /delete/{id}	
Register	Post	/auth/post	{
  "name": "string",
  "email": "string",
  "password": "string",
  "login": "string",
  "phone": "string"
}
FocusGroupsAll	Get	/focusgroup/get	
ChangePassword	Patch	/auth/password	{
  "password": "string",
  "login": "string"
}
FocusGroupMembers	Get	/focusgroup/get/{id}/users	
AddMemberToGroup	Post	/focusgroup/post/{id}/users	{
  "userId": 0
}
UserUpdate	Patch	/users/patch/{id}	{
  "name": "string",
  "email": "string",
  "password": "string",
  "login": "string",
  "phone": "string"
}
SessionsGet	Get	/sessions/get	
DeleteFromGroup	Delete	/ focusgroup/delete/{id}	
ReactionsGet	Get	/reactions/get	
ReactionDelete	Delete	/reactions/delete/{id}	
ReactionsByUserId	Get	/reactions/get/byUser/{userId}	
ReactionUpdate	Patch	/reactions/patch/{id}	{
 "comment": "string", "grade": "integer", "interestRate": "integer" 
}
ReactionsByContentId	Get	/reactions/get/byContent/{contentId}	
SessionsByGrouptId	Get	/sessions/get/byGroup/{id}	
ContentGet	Get	/content/get	
FocusGroupById	Get	/users/get/byFocusGroup/{focusId}	
Login	Post	/Auth/login	{
 "login": "string", "password": "string" 
}
FocusGroupAdd	Post	/focusgroups/post	{
 "race": "string", "age": "string", "gender": "string" 
}
SessionAdd	Post	/sessions/post	{
 "focGrId": "integer", "contentId": "integer", "startTime": "date", "endTime": "date" 
}
ReactionAdd	Post	/reactions/post	{
 "userId": "integer", "contentId": "integer", "comment": "string", "grade": "integer", "interestRate": "integer" 
}
FocusGroupEdit	Patch	/focusgroups/patch/{id}	{
 "race": "string", "age": "string", "gender": "string" 
}
ContentAdd	Post	/content/post	{
 "title": "string", "type": "string", "description": "string", "URL": "string" 
}
ReactionsByGroup	Get	/sessions/group/{groupId}/content/{contentId}	
ResultBySession	Get	/result/session/{sessionId}	
ResultByContent	Get	/result/content/{contentId}	
DeleteFromGroup	Delete	/group/{userId}/{groupId}	

 
ДОДАТОК Б


import time
import random
from machine import ADC, Pin
from umqtt.simple import MQTTClient
import network
import ujson

# Настройки MQTT
MQTT_CLIENT_ID = "micropython-emotion-demo"
MQTT_BROKER = "broker.mqttdashboard.com"
MQTT_USER = ""
MQTT_PASSWORD = ""
MQTT_TOPIC = "wokwi-emotion"

print("Connecting to WiFi", end="")
sta_if = network.WLAN(network.STA_IF)
sta_if.active(True)
sta_if.connect('Wokwi-GUEST', '')
while not sta_if.isconnected():
    print(".", end="")
    time.sleep(0.1)
print(" Connected!")

print("Connecting to MQTT server... ", end="")
client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER, user=MQTT_USER, password=MQTT_PASSWORD)
client.connect()
print("Connected!")

bpm_pin = ADC(Pin(35))

def read_bpm():
    raw_value = bpm_pin.read()
    bpm_value = int(40 + (raw_value / 4095.0) * 130)
    return bpm_value

def generate_values():
    humidity = random.uniform(30.0, 90.0) + random.uniform(-5.0, 5.0)
    temperature_c = random.uniform(36.5, 38.0) + random.uniform(-0.5, 0.5)
    return temperature_c, humidity

def is_angry(average_temp, average_humidity, bpm_changes):
    return average_temp > 37.5 and average_humidity > 70 and max(bpm_changes) > 10

def is_sad(average_temp, average_humidity, bpm_changes):
    return 37.0 <= average_temp <= 37.5 and 50 <= average_humidity <= 70 and max(bpm_changes) <= 10

def is_boring(average_temp, average_humidity, bpm_changes):
    return average_temp < 37.0 and average_humidity < 50 and max(bpm_changes) < 5

def is_happy(average_temp, average_humidity, bpm_changes):
    return 36.5 <= average_temp <= 37.0 and 40 <= average_humidity <= 60 and 5 <= max(bpm_changes) <= 15

def determine_emotion(average_temp, average_humidity, bpm_changes):
    if is_angry(average_temp, average_humidity, bpm_changes):
        return "angry"
    elif is_sad(average_temp, average_humidity, bpm_changes):
        return "sad"
    elif is_boring(average_temp, average_humidity, bpm_changes):
        return "boring"
    elif is_happy(average_temp, average_humidity, bpm_changes):
        return "happy"
    else:
        return "neutral"

def analyze_data(data):
    avg_temp = sum([d[0] for d in data]) / len(data)
    avg_humidity = sum([d[1] for d in data]) / len(data)
    bpm_values = [d[2] for d in data]
    bpm_changes = [abs(bpm_values[i+1] - bpm_values[i]) for i in range(len(bpm_values)-1)]
    
    return determine_emotion(avg_temp, avg_humidity, bpm_changes)

def main():
    data = []
    start_time = time.time()

    while True:
        temperature_c, humidity = generate_values()
        bpm = read_bpm()

        data.append((temperature_c, humidity, bpm))
        
        if time.time() - start_time >= 5:
            dominant_emotion = analyze_data(data)
            print(f"Dominant Emotion: {dominant_emotion}")
            
            client.publish(MQTT_TOPIC, dominant_emotion)
            print(f"Sent to MQTT: {dominant_emotion}")
            
            data.clear()
            start_time = time.time()
        
        time.sleep(1)       

main()



